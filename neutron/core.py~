import astropy.io.fits as pyfits
import numpy as np
import pyaudio
import wave
import sys
import pylab as pl
import multiprocessing
from matplotlib.backend_bases import MouseButton
import time

class Machine(object):

    def __init__(self, path):

        self.mgr = multiprocessing.Manager()
        self.p = self.mgr.dict()

        self.player_process = multiprocessing.Process(
            name='player', 
            target=Player, 
            args=(path, self.p))

        self.viewer_process = multiprocessing.Process(
            name='viewer', 
            target=Viewer, 
            args=(path, self.p))

        self.player_process.start()
        self.viewer_process.start()
        
        self.player_process.join()
        self.viewer_process.join()
        
        

class Player(object):

    def __init__(self, path, nchannels=2, rate=44100, sample_width=2, p=dict()):
        self.data = pyfits.open(path)[0].data
        self.reset_norm()
        self.shape = np.array(self.data.shape)
        
        self.audio = pyaudio.PyAudio()

        
        # self.stream = self.audio.open(
        #     format=self.audio.get_format_from_width(sample_width),
        #     channels=nchannels,
        #     rate=rate,
        #     output=True)

        self.p = p
        self.p['harm_number'] = 1
        self.p['harm_step'] = 30
        self.p['center'] = (self.shape / 2).astype(int)
        self.p['size'] = 30
        self.p['stop'] = False

        self.play()
        
        
    def reset_norm(self, perc=99):
        self.norm = np.nanpercentile(self.data, perc)

    def _get_box(self, pos, size):
        if len(pos) != self.data.ndim:
            raise Exception('center must be a tuple of length {}'.format(self.data.ndim))
        center = np.clip(pos, size, self.shape - size)
        slices = tuple([slice(c - size, c + size + 1) for c in center])
        return self.data.__getitem__(slices)
    
    def get_sound(self):
        center = tuple(self.p['center'])
        s = int(self.p['size'])
        box = self._get_box(center, s).flatten()
        for i in range(self.p['harm_number']):
            box += self._get_box(center, s + i * self.p['harm_step']).flatten()[:box.size]
            
        return box
        
    def play_sample(self):  
        sample = self.get_sound()
        
        sample /= self.norm
        sample -= np.mean(sample)
        sample *= 2**15 - 1
        
        self.stream.write(sample.astype(np.int16))

    def play(self):
        while not self.p['stop']:
            time.sleep(0.1)
            #self.play_sample()
            print(self.p['center'])
            pass
        self.p['stop'] = False


class Viewer(object):


    def __init__(self, path, p=dict()):
        self.data = pyfits.open(path)[0].data
        self.p = p
        self.show()
        
    def show(self):
        self.fig, self.ax = pl.subplots()
        if self.data.ndim == 2:
            self.ax.imshow(self.data)
        else: raise NotImplementedError('not implemented for a cube')

        self.fig.canvas.mpl_connect('motion_notify_event', self.mouse_onmove)
        
        pl.show()
        
        
    def mouse_onmove(self, event):
        if event.button is MouseButton.LEFT:
            self.p['center'][0] = int(event.xdata)
            self.p['center'][1] = int(event.ydata)
            
    
